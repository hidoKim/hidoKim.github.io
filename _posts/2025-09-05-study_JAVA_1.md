---
layout: single
title: "[JAVA] 자바 collections framework"
categories: JAVA_study
tags: [JAVA_study, study]
toc: true
author_profile: false
---

# 생활코딩 강의 정리

## JAVA: Collections frameworks

### 1. ArrayList의 사용법

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=KaPbVAxi5LE&list=PLuHgQVnccGMCeAy-2-llhw3nWoQKUvQck&index=151)

#### ArrayList

- 배열은 정해진 크기 이상의 데이터를 넣으려고 하면 오류가 생김
- 이 오류를 해결하기 위한 방법이 ArrayList

#### 배열 vs ArrayList

- .length == .size()
- obj[i] == .get(i)

#### ArrayList 사용시 주의할 점

- ArrayList의 기본형은 object이기 때문에 genetic을 사용해서 형변환을 해야함.
- (String)를 이용해 형변환을 해도 됨 -> 옛날 방식

---

#### 실습코드

```java
package arrayTest;

import java.util.ArrayList;

public class ArrayListDemo {
    public static void main(String[] args) {
        String[] arrayObj = new String[2];
        arrayObj[0] = "one";
        arrayObj[1] = "two";
        //arrayObj[2] = "three"; // 오류가 발생한다.

        for (int i = 0; i < arrayObj.length; i++) {
            System.out.println(arrayObj[i]);
        }

        ArrayList<String> al = new ArrayList<String>(); //<>는 genetic
        al.add("one"); // object Type
        al.add("two");
        al.add("three");
        for (int i = 0; i < al.size(); i++) {
            String value = al.get(i);
            System.out.println(value);
        }
    }
}
```

### 2. Collections framework 전체적인 구성

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=E_WMaPuY_oA&t=21s)

#### collections framework 란?

- Collection
  - Set
    - HashSet
    - LinkedHashSet
    - TreeSet
  - List
    - ArrayList
    - Vector
    - LinkedList
  - Queue
    - PriorotyQueue
- Map
  - SortedMap
    - TreeMap
  - Hashtable
  - LinkedHashMap
  - HashMap

### 3. List와 Set의 차이점

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=c_3CN5Chy54&t=3s)

#### HashSet

HashSet 사용법

- HashSet에 1,2,3을 저장

---

#### 실습코드

```java
package set;

import java.util.HashSet;
import java.util.Iterator;

public class SetDemo {
    public static void main(String[] args) {
        HashSet<Integer> A = new HashSet<Integer>();
        A.add(1);
        A.add(2);
        A.add(3);
        // A HashSet안에 1,2,3 이라는 값이 들어감

        Iterator hi = (Iterator) A.iterator();
        while(hi.hasNext()){
            System.out.println(hi.next()); // 1 2 3 출력됨
        }

    }
}

```

- HashSet에 1,1,2,2,3,3을 저장

```java
package set;

import java.util.HashSet;
import java.util.Iterator;

public class SetDemo {
    public static void main(String[] args) {
        HashSet<Integer> A = new HashSet<Integer>();
        A.add(1);
        A.add(1);
        A.add(2);
        A.add(2);
        A.add(3);
        A.add(3);
        // A HashSet안에 1,2,3 이라는 값이 들어감

        Iterator hi = (Iterator) A.iterator();
        while(hi.hasNext()){
            System.out.println(hi.next()); // 1 2 3 출력됨
        }

    }
}
```

- ArrayList에 1,1,2,2,3,3을 저장

```java
package set;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

public class SetDemo {
    public static void main(String[] args) {
        ArrayList<Integer> A = new ArrayList<>();
        A.add(1);
        A.add(1);
        A.add(2);
        A.add(2);
        A.add(3);
        A.add(3);
        // A ArrayList안에 1,2,3 이라는 값이 들어감

        Iterator hi = (Iterator) A.iterator();
        while(hi.hasNext()){
            System.out.println(hi.next()); // 1 1 2 2 3 3 출력됨
        }

    }
}

```

**HashSet**은 중복저장이 불가하지만 **ArrayList**는 중복저장이 가능하다.

### 4. Set이란?

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=if3ojZRsGXo)

#### 집합과 Set

- 수학의 집합과 Set은 동일하다.
- 집합 안의 값들은 각각 고유하다.
- Set 안의 값들은 각각 고유하다.
- List는 순서대로 저장되지만 (순서가 보장되지만) Set은 순서가 보장되지 않는다.

#### containsAll()

- A.containsAll(B) -> B는 A의 부분 집합이다. (A가 B의 모든 값을 가지고 있다)
- A.containsAll(C) -> C는 A의 부분 집합이다. (A가 C의 모든 값을 가지고 있다)

#### addAll()

- A.addAll(B) -> A와 B의 합집합 (B를 A에 더한다)

#### retainAll()

- A.retainAll() -> A와 B의 교집합 (A,B 모두에 있는 값)

#### removeAll()

- A.removeAll() -> A와 B의 차집합 (A - B)

---

#### 실습코드

```java
package set;

import java.util.HashSet;

public class SetDemo2 {
    public static void main(String[] args) {
        HashSet<Integer> A = new HashSet<>();
        A.add(1);
        A.add(2);
        A.add(3);
        // A에 1, 2, 3 추가

        HashSet<Integer> B = new HashSet<>();
        B.add(3);
        B.add(4);
        B.add(5);
        // B에 3, 4, 5 추가

        HashSet<Integer> C = new HashSet<>();
        C.add(1);
        C.add(2);
        // C에 1, 2 추가

        System.out.println(A.containsAll(B)); // false
        System.out.println(A.containsAll(C)); // true
```

```java
        A.addAll(B); // B를 A에 add
        System.out.println(A); // [1, 2, 3, 4, 5]가 출력됨
```

```java
        A.retainAll(B); // A와 B의 교집합
        System.out.println(A); // [3]이 출력됨
```

```java
        A.removeAll(B); // A - B (A와 B의 차집합)
        System.out.println(A)ㄴ; // [1, 2]가 출력됨
    }
}
```

### 5. Collection interface

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=rHPaEJmfa98)

#### 컬렉션과 인터페이스

- Collection, List, Set : 인터페이스
- HashSet, ArrayList : 클래스

#### index API

- **List**는 순서가 있음 -> **index**(인덱스)를 이용해 접근가능

  - Object get/set(int **index**)
  - Object set(int **index**, Object element)
  - void add(int **index**, Object element)

- 반면에 **Set**은 순서가 없음 -> 인덱스를 이용해 접근 불가
  - 위의 **get/set/add** 등을 사용하지 않음

### 6. iterator

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=DQN32cBaUEE)

#### iterator()

이터레이터 메소드: 반복자

- 이터레이터는 **Collection 인터페이스**
  - HashSet, ArrayList, Collection에서 모두 사용가능

#### hasNext()

- 이터레이터 안에 값이 있는지 확인.
- 있으면 **True** 없으면 **False**

#### next()

- 이터레이터 안의 값을 리턴 후 삭제.
  - 이터레이터 안의 값이 삭제 되는 것.
  - 이터레이터 안의 값을 삭제한다고 해서 오리지날 값이 사라지는 것은 아님.

---

#### 실습코드

```java
package set;

import java.util.HashSet;
import java.util.Iterator;

public class SetDemo {
    public static void main(String[] args) {
        HashSet<Integer> A = new HashSet<Integer>();
//        ArrayList<Integer> A = new ArrayList<Integer>(); // arrayList 가능
//        Collection<Integer> A = new HashSet<Integer>(); // collection 가능
        A.add(1);
        A.add(2);
        A.add(3);

        Iterator hi = A.iterator(); // hi라는 이터레이터 생성 후 A의 데이터를 hi에 저장
        while(hi.hasNext()){ // hi에 값이 있으면 실행
            System.out.println(hi.next()); // 현재의 값을 출력 후 삭제하고 다음으로 넘어감
        }
    }
}

```

### 7. Map의 기본 사용법 (1/2)

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=Jg7x2XlteWk)

#### Map

중간 점검

- List
  - 데이터가 입력되면 순서대로 (0~n) 데이터가 추가됨
- Set
  - 데이터가 입력되면 데이터가 순서와 상관없이, 중복 없이 추가됨
- **Map**
  - 데이터가 입력되면 "key : value" 형태로 추가됨

> key 값은 중복될 수 없지만 value 값은 중복을 허용함

#### 실습코드

```java
package map;

import java.util.HashMap;

public class MapDemo {
    public static void main(String[] args) {
        HashMap<String, Integer> a = new HashMap<String, Integer>();
        // genetic을 통해 key 값과 value 값의 데이터 타입을 지정

        a.put("one", 1); // key: "one", value: 1
        a.put("two", 2);
        a.put("three", 3);
        a.put("four", 4);

        System.out.println(a.get("one")); // 1
        System.out.println(a.get("two")); // 2
        System.out.println(a.get("three")); // 3

    }
}

```

### 8. Map의 기본 사용법 (2/2)

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=7goT8ErUFgU)

#### Map의 반복 처리방법 1

**iteratorUsingForEach(a)**

```java
    // 반복 처리방법 1
    static void iteratorUsingForEach(HashMap map){ // a가 map으로 들어옴
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
    }

```

`Set<Map.Entry<String, Integer>> entries = map.entrySet();`

- `map.entrySet()`

  - map의 key, value 쌍 전체를 set 컨테이너(`Set<Map.Entry<K,V>>`) 형태로 반환

- `Set<Map.Entry<String, Integer>> entries`

  - 반환된 Set의 각 요소(Entry)는 key와 value를 담고 있는 Map.Entry 객체
  - Set 전체가 Map.Entry들의 집합

  - Entry 안의 getKey와 getValue가 Map의 Key, Value를 가져와서 entries 안에 저장
    - entries안의 데이터 타입은 Map.Entry
    - entries의 테이터 타입은 Set

`for-each 문`

- `for (Map.Entry<String, Integer> entry : entries)`
  - entries (Set)에 담긴 각각의 key-value 쌍 (Map.Entry)에 대해 반복하며 루프를 돔

#### Map의 반복 처리방법 2

**iteratorUsingIterator(a)**

```java
     // 반복 처리방법 2
    static void iteratorUsingIterator(HashMap map){
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        Iterator<Map.Entry<String, Integer>> i = entries.iterator();
        while (i.hasNext()) {
            Map.Entry<String, Integer> entry = i.next();
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
    }
```

`Iterator<Map.Entry<String, Integer>> i = entries.iterator();`

- entries는 Set이기 때문에 iterator()를 통해 반복할 수 있는 반복자를 얻어 낼 수 있음

`while (i.hasNext()) {`

- Iterator안에 반복할 데이터가 있는지 확인, 있으면 while문 시작

`Map.Entry<String, Integer> entry = i.next();`

- Iterator안에 저장되어있는 값을 하나씩 꺼내서 entry에 저장

`System.out.println(entry.getKey() + " : " + entry.getValue()); }`

#### 실습코드

```java
package map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class MapDemo2 {
    public static void main(String[] args) {
        HashMap<String, Integer> a = new HashMap<String, Integer>();
        a.put("one", 1); // key: "one", value: 1
        a.put("two", 2);
        a.put("three", 3);
        a.put("four", 4);

        // 반복 처리방법 1
        iteratorUsingForEach(a);

        // 반복 처리방법 2
        iteratorUsingIterator(a);
    }

    // 반복 처리방법 1
    static void iteratorUsingForEach(HashMap map){ // a가 map으로 들어옴
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
    }

    // 반복 처리방법 2
    static void iteratorUsingIterator(HashMap map){
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        Iterator<Map.Entry<String, Integer>> i = entries.iterator();
        while (i.hasNext()) {
            Map.Entry<String, Integer> entry = i.next();
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
    }
}

```

### 9. Collections의 사용법과 정렬

이 글은 아래의 강의를 보고 작성한 포스트 입니다.

- [Java : Collections framework](https://www.youtube.com/watch?v=twTt4IN94X0)

#### 데이터 정렬

a.compareTo(b)

- a가 크면 양수, 같으면 0, a가 작으면 음수

#### 실습코드

```java
package collections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

class Computer implements Comparable {
    int serial;
    String owner;
    Computer(int serial, String owner) {
        this.serial = serial;
        this.owner = owner;
    }

    public int compareTo(Object o) { // Comparable은 compareTo 메소드를 구현하도록 강제함
        return this.serial - ((Computer)o).serial;
        // Computer 객체와 현재의 객체를 비교
        // 같다면 0, 현재의 객체가 크면 양수, 작으면 음수
        // a.serial - b.serial : a와 b의 serial 값을 비교
    }
    public String toString(){
        return serial+" "+owner;
    }
}

public class CollectionsDemo {
    public static void main(String[] args) {
        List<Computer> computers = new ArrayList<Computer>();
        computers.add(new Computer(500, "egoing"));
        computers.add(new Computer(200, "leezche"));
        computers.add(new Computer(3233, "graphittie"));

        Iterator i = computers.iterator();
        // 정렬 전
        System.out.println("before");
        while(i.hasNext()){
            System.out.println(i.next()); // arrayList의 순서대로 출력됨
        }

        Collections.sort(computers);
        // 정렬 후
        System.out.println("\nafter");
        i = computers.iterator();
        while(i.hasNext()){
            System.out.println(i.next()); // serial num이 작은 순으로 출력됨
        }
    }
}

```
